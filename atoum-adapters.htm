<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jubianchi.fr</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Julien Bianchi <contact@jubianchi.fr>">

    <link href="data:image/x-icon;base64,AAABAAEAEBAQAAAAAAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAenp6AO6//wD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABERERERAAABEQAAAAEQABIhARARASIAEiERERERIgAREAERAQARABETARERMBEAEREREREREQABEREREREQAAEREAABERAAAREAAAABEAABEAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//wAA4AcAAMADAACAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAQAAgAEAAIPBAACH4QAAz/MAAP//AAD//wAA" rel="icon" type="image/x-icon" />

    <link href='http://fonts.googleapis.com/css?family=Exo+2:400,100,200,300' rel='stylesheet' type='text/css'>
    <link href="styles/style.css" rel="stylesheet">
</head>

<body>

<header>
    <a href="/index.htm"><img id="avatar" src="images/nyantocat.gif"/></a>

    <h1>Julien Bianchi <small><em>aka jubianchi</em></small></h1>

    <ul>
        <li><a href="mailto:contact@jubianchi.fr" title="email">email</a></li>
        <li><a href="https://twitter.com/jubianchi" title="twitter">twitter</a></li>
        <li><a href="https://github.com/jubianchi" title="github">github</a></li>
        <li><a href="https://speakerdeck.com/jubianchi" title="speakerdeck">speakerdeck</a></li>
        <li><a href="https://coderwall.com/jubianchi" title="coderwall">coderwall</a></li>
        <li><a href="http://osrc.dfm.io/jubianchi" title="Open Source Report Card">OSRC</a></li>
        <li><a href="cv/index.html" title="jubianchi.fr">CV</a></li>
    </ul>
</header>
    <section>
        <time datetime="2012-12-04 12:16:00">
            <strong>Dec</strong>
            <span>04</span>
            <em>2012</em>
        </time>

        <div class="left">
            <h1>Tests unitaires et adapters avec atoum</h1>

            <p>Nous avons récemment eu quelques discussions sur les <em>adapters</em> sur le salon IRC de atoum (pour rappel, celui-ci se
trouve sur les serveurs Freenode, canal ##atoum). Plusieurs questions ont été traitées : nous avons parlé de l'utilité
de ces <em>adapters</em>, des possibilités qu'ils offrent dans le cadre de tests unitaires mais également des inconvénients et
des bonnes pratiques à mettre en place pour bien les utiliser. Je vais donc tenter ici d'eclaircir ces quelques points
à travers des exemples relativement simples. J'utiliserais <em>atoum</em> pour les tests qui seront écrits pour une classe
gérant une connexion à un serveur FTP.</p>

<h3>Le pattern Adapter</h3>

<p>Avant de commencer, nous allons faire un petit rappel sur le design pattern <em>Adapter</em>. Voici un extrait de la définition
donnée par Wikipedia :</p>

<blockquote>
  <p>The adapter translates calls to its interface into calls to the original interface, and the amount of code necessary
  to do this is typically small.</p>
  
  <p>— <a href="http://en.wikipedia.org/wiki/Adapter_pattern">Wikipedia - Adapter Pattern</a></p>
</blockquote>

<p>Cette définition nous dit que l'<em>Adapter</em> traduit des appels d'une interface vers une autre avec un minimum de code. En
d'autres termes, elle n'est qu'un proxy.</p>

<h3>L'intérêt des Adapters pour les tests unitaires</h3>

<p>Lorsqu'on souhaite utiliser les tests unitaires pour valider notre code de la manière la plus approfondie possible, il
est souvent nécessaires d'utiliser certaines bonnes pratiques qui permettent de mettre en place cette stratégie.
Vous avez donc certainement entendu parler de l'injection de dépendances par exemple qui règle très bien certains
problèmes : ma classe testée à besoin d'une autre classe pour fonctionner et celle-ci lui sera injectée au moment voulu
dans les tests, idéalement sous forme de mock. Mais qu'en est-il lorsque la classe testée est directement dépendante
de l'environement.</p>

<p>Mais qu'est ce que "dépendante de l'environement" signifie ? A un moment, vous vous retrouverez certainement avec des
méthodes qui utilisent des fonctions natives de PHP pour tester l'existence d'un fichier par exemple ou, pour rester
dans le cadre de l'exemple que je vais introduire par la suite, qui se connecte à des serveurs FTP toujours via les
fonctions natives du langage. A ce moment là, vous aurez certainement des difficultés pour tester tous les cas possibles
dans votre code : mon fichier existe ou n'existe pas, le serveur FTP est disponible, le login entré est invalide, ...
Les <em>adapters</em> sont là pour nous permettre de tester ces cas très simplement et de manière très intuitive (en tout cas
avec <em>atoum</em>)</p>

<h3>Sans les adapters</h3>

<p>Comme je vous le disais, nous allons travailler sur un exemple présentant une classe qui permet de se connecter à un
serveur FTP via les fonctions natives de PHP. Cet exemple est assez basique mais il a l'avantage de montrer rapidement
les problèmes que l'on peut rencontrer :</p>

<pre><code>&lt;?php
namespace tests\unit {
    use
        mageekguy\atoum,
        Ftp as TestedClass
    ;

    class Ftp extends atoum\test {
        public function test__construct() {
            $this
                -&gt;object(new TestedClass())-&gt;isInstanceOf('\\Ftp')
            ;
        }
    }
}

namespace {
    class Ftp
    {
        public function __construct()
        {
            if (false === extension_loaded('ftp')) {
                throw new \RuntimeException('FTP extension is not loaded');
            }
        }

        //...
    }
}


$ bin/atoum -f tests/listing/Adapter/1.php

&gt; tests\unit\Ftp...
[S___________________________________________________________][1/1]
=&gt; Test duration: 0.00 second.
=&gt; Memory usage: 0.50 Mb.
&gt; Total test duration: 0.00 second.
&gt; Total test memory usage: 0.50 Mb.
&gt; Code coverage value: 66.67%
=&gt; Class Ftp: 66.67%
==&gt; Ftp::__construct(): 66.67%
</code></pre>

<p>Nous avons donc notre test unitaire qui va vérifier que l'instanciation de notre classe <code>Ftp</code> se passe bien.
Pour que ce test passe, il faudra obligatoirement que la machine qui l'exécute ait l'extension PHP FTP installée et
activée. Si cette condition n'est pas respectée, une exception sera levée et notre test passera au rouge.</p>

<p>Si nous souhaitons tester cette exception, il faudra obligatoirement que la machine exécutant les tests n'ait pas
l'extension requise.</p>

<p>En d'autres termes, il va être très difficile de tester les deux cas dans un seul test unitaire exécuté sur la même
machine à moins de passer par des "hacks" que je ne détaillerais pas ici.</p>

<p>Rappelez-vous bien une chose : nous sommes dans le cadre de tests unitaires et il serait très dommage de les coupler
à l'environnement sur lequel ils sont exécutés, c'est donc là que les <em>adapters</em> vont nous aider.</p>

<h3>Comment utiliser les Adapters</h3>

<p>Les classes qui utiliseront l'<em>adapter</em> auront donc une dépendance supplémentaire vers ce proxy. Ne vous inquiétez pas,
dans l'idéal, votre code sera fait de telle manière que l'injection de cette dépendance soit optionnelle. Voyons tout
de suite un extrait de code qui illustre mes propos :</p>

<pre><code>&lt;?php
use
    mageekguy\atoum
;

class Ftp
{
    private $adapter;

    public function __construct(atoum\adapter $adapter = null)
    {
        $this-&gt;setAdapter($adapter);

        if (false === $this-&gt;getAdapter()-&gt;extension_loaded('ftp')) {
            throw new \RuntimeException('FTP extension is not loaded');
        }
    }

    public function setAdapter(atoum\adapter $adapter = null)
    {
        $this-&gt;adapter = $adapter;

        return $this;
    }

    public function getAdapter()
    {
        if (null === $this-&gt;adapter) {
            $this-&gt;adapter = new atoum\adapter();
        }

        return $this-&gt;adapter;
    }

    //...
}
</code></pre>

<p>Comme vous pouvez le constater à travers cet extrait de code, l'injection de l'<em>adapter</em> est optionnelle et dans le cas
où celui-ci n'est pas fourni, un <em>adapter</em> par défaut sera créé et utilisé au sein de la classe <code>Ftp</code>.
Nous autorisons également l'injection de cette dépendance par le constructeur et par un mutateur (setter) : cela nous
permettra d'injecter l'<em>adapter</em> adéquat dans les tests unitaires.</p>

<p>Vous avez certainement noté que le constructeur de notre classe <code>Ftp</code> a été modifié : l'appel à
<code>extension_loaded</code> passe désormais par notre <em>adapter</em> et cela va nous permettre d'étoffer notre test unitaire et
d'y ajouter quelques cas supplémentaires :</p>

<pre><code>&lt;?php
class Ftp extends atoum\test {
    public function test__construct() {
        $this
            -&gt;if($adapter = new atoum\test\adapter())
            -&gt;and($adapter-&gt;extension_loaded = true)
            -&gt;then
                -&gt;object(new TestedClass($adapter))-&gt;isInstanceOf('\\Ftp')

            -&gt;if($adapter-&gt;extension_loaded = false)
            -&gt;then
                -&gt;exception(
                    function() use($adapter) {
                        new TestedClass($adapter);
                    }
                )
                    -&gt;isInstanceOf('\\RuntimeException')
                    -&gt;hasMessage('FTP extension is not loaded')
        ;
    }
}


$ bin/atoum -f tests/listing/Adapter/2-3.php

&gt; tests\unit\Ftp...
[S___________________________________________________________][1/1]
=&gt; Test duration: 0.01 second.
=&gt; Memory usage: 0.50 Mb.
&gt; Total test duration: 0.01 second.
&gt; Total test memory usage: 0.50 Mb.
&gt; Code coverage value: 80.00%
=&gt; Class Ftp: 80.00%
==&gt; Ftp::getAdapter(): 50.00%
</code></pre>

<p>On se rend immédiatement compte des avantages que l'<em>adapter</em> nous procure : nous sommes maintenant capable de tester
notre classe sans nous soucier de la configuration de la machine exécutant les tests. Et en bonus, nous avons la
possibilité de simuler la présence ou l'absence de l'extension ce qui nous permet d'obtenir une couverture plus
importante (nous sommes passé de 67% à 80%) !</p>

<p>Notre code y gagne en testabilité et donc en fiabilité si les tests adéquats sont mis en place. La contrepartie, c'est
que nous sommes désormais dépendant de l'<em>adapter</em> et que cela peut nous jouer des tours dans certains cas
(les performances peuvent par exemples être impactées).</p>

<h3>Attentions aux pièges !</h3>

<h4>Ne pas être dépendant du framework de test dans le code de production</h4>

<p>L'utilisation des <em>adapters</em> apporte beaucoup de choses mais il faut les utiliser avec précaution. Si vous remontez au
paragraphe précédent, vous verrez que le code de la classe <code>Ftp</code> est maintenant dépendant de l'<em>adapter</em> par défaut
d'<em>atoum</em> : dans l'idéal, il faut éviter cela ! Votre code de production ne doit en aucun cas avoir de dépendance forte
avec votre framework de test ! Mais comment contourner cela ?</p>

<p>Afin de décoreller votre projet du framework de test, il vous faudra écrire quelques interfaces qui vous permettront
d'abstraire cette dépendance et éventuellement de migrer vers un autre framework de test sans trop de douleur.</p>

<p>Je vais vous présenter ici la méthode que j'utilise afin d'arriver à un tel résultat, à savoir, un <em>adapter</em> indépendant
du framework de test :</p>

<pre><code>&lt;?php
namespace {
    interface AdapterInterface
    {
        public function invoke($name, array $args = array());
    }

    class Adapter implements AdapterInterface
    {
        public function invoke($name, array $args = array())
        {
            if (is_callable($name)) {
                return call_user_func_array($name, $args);
            }

            throw new \RuntimeException(sprintf('%s is not callable', var_export($name)));
        }

        public function __call($name, $args)
        {
            return $this-&gt;invoke($name, $args);
        }
    }
}

namespace Test {
    use
        mageekguy\atoum\test\adapter as AtoumAdapter
    ;

    class Adapter extends AtoumAdapter implements \AdapterInterface
    {
    }
}
</code></pre>

<p>Nous définissons donc, dans notre projet, une interface standard qui décrit nos <em>adapters</em> ainsi, nos classes seront
dépendantes de cette abstraction :</p>

<pre><code>&lt;?php
class Ftp
{
    private $adapter;

    public function __construct(AdapterInterface $adapter = null)
    {
        $this-&gt;setAdapter($adapter);

        if (false === $this-&gt;getAdapter()-&gt;extension_loaded('ftp')) {
            throw new \RuntimeException('FTP extension is not loaded');
        }
    }

    public function setAdapter(AdapterInterface $adapter = null)
    {
        $this-&gt;adapter = $adapter;

        return $this;
    }

    public function getAdapter()
    {
        if (null === $this-&gt;adapter) {
            $this-&gt;adapter = new Adapter();
        }

        return $this-&gt;adapter;
    }

    //...
}



$ bin/atoum -f tests/listing/Adapter/4-5.php

&gt; tests\unit\Ftp...
[S___________________________________________________________][1/1]
=&gt; Test duration: 0.01 second.
=&gt; Memory usage: 0.50 Mb.
&gt; Total test duration: 0.01 second.
&gt; Total test memory usage: 0.50 Mb.
&gt; Code coverage value: 80.00%
=&gt; Class Ftp: 80.00%
==&gt; Ftp::getAdapter(): 50.00%
</code></pre>

<p>Comme vous pouvez le voir, la dépendance vers <em>atoum</em> a disparue de notre code de production ! Nous sommes maintenant
dépendant de notre <code>Adapterinterface</code> et de l'implémentation par défaut que nous avons ajoutée.</p>

<h4>Attention aux performances</h4>

<p>Nous avons vu dans l'exemple précédent comment découpler facilement nos <em>adapters</em> du framework de test. Pour cela, nous
avons mis en place une interface : désormais, toutes nos classes nécessitant un <em>adapter</em> peuvent se reposer sur cette
interface. Nous avons également mis en place une implémentation par défaut afin de répondre à un maximum de besoin
rapidement et avec un minimum de code (souvenez-vous de la définition de Wikipedia).</p>

<p>Cette implémentation a un inconvénient majeur : afin de combler un maximum de besoin, cette classe se base sur la
fonction PHP <code>call_user_func_array</code>. Dans certains cas, cette méthode peu être coûteuse en terme de temps
d'exécution (voir mon benchmark <a href="https://github.com/jubianchi/PHPSandbox/tree/master/call_user_func">ici</a>) : la
différence est négligeable dans le cas de ce benchmark mais on remarque quand même des écart pouvant aller
jusqu'à environ 5% !</p>

<p>Pour corriger ce problème, il faut se plonger un peu plus dans la théorie du pattern <em>adapter</em> : à la base, ce pattern
a été imaginé dans le but d'abstraire d'une dépandence. Il va décrire, via son interface, les besoins de la classe
cliente et, à travers ses différentes implémentations, y répondre. Donc, en théorie, votre code de production devrait
dépendre d'un <em>Adapter</em> spécifique à chaque cas : dans notre exemple, la classe <code>Ftp</code> devrait dépendre d'un <code>FtpAdapter</code>
qui fournirait l'implémentation des méthodes nécessaires.</p>

<h4>Attention aux abus</h4>

<p>Comme toute technique utilisée en programmation, les <em>adapters</em> demandent à être utilisé avec précaution et surtout de
manière judicieuse : il ne faut pas en abuser (par exemple, ne passez pas tous vos appels à <code>sprintf</code> par un <code>Adapter</code> : dans la plupart des cas (tous ?) , ce sera inutile).
Identifiez les cas où l'utilisation de ceux-ci vous apporte réellement un plus au niveau de la testabilité et/ou de
l'architecture de vos composants.</p>

<pre><code>&lt;?php
// INUTILE
$this-&gt;getAdapter()-&gt;file_get_contents($this-&gt;getAdapter()-&gt;md5($value) . '.txt');

// CORRECT
$this-&gt;getAdapter()-&gt;file_get_contents(md5($value) . '.txt');

// ADAPTER
$adapter-&gt;file_get_contents = function() { return 'foobar'; };
</code></pre>

        </div>
    </section>

            <ul class="list tags">
                            <li><a href="#" class="label">php</a></li>
                            <li><a href="#" class="label">atoum</a></li>
                            <li><a href="#" class="label">test</a></li>
                    </ul>
    
    <section id="disqus_thread"></section>

<script type="text/javascript">
    var disqus_shortname = 'jubianchifr';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<footer>
    <p>Github CSS logo authored by <a href="http://www.bchanx.com/" title="Brian Chan">Brian Chan</a> : <a href="https://github.com/bchanx/logos-in-pure-css">https://github.com/bchanx/logos-in-pure-css</a></p>
    <p>Politician designed by <a href="http://thenounproject.com/moshiah/" title="Benjamin Harlow">Benjamin Harlow</a> from the <a href="http://www.thenounproject.com/">Noun Project</a></p>
    <p>Juggle designed by <a href="http://thenounproject.com/Gatada" title="Johan H. W. Basberg">Johan H. W. Basberg</a> from the <a href="http://www.thenounproject.com/">Noun Project</a></p>
</footer>

</body>
</html>
